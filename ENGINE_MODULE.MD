# ðŸŽ® Hard-Stakes: Game Engine Module (MagicBlock)

Enquanto o MÃ³dulo BancÃ¡rio (Bank) protege o dinheiro com cofres e regras rÃ­gidas, o Engine Module Ã© o cÃ©rebro Ã¡gil do jogo. Ele foi desenhado para rodar sobre a infraestrutura de Ephemeral Rollups da MagicBlock, permitindo uma jogabilidade fluida (sub-50ms) que seria impossÃ­vel na Mainnet da Solana padrÃ£o.

## ðŸŽï¸ Arquitetura: Ephemeral Rollups

Este nÃ£o Ã© um Smart Contract comum. Ele opera em dois modos:

### Modo "Base" (Solana L1):
- Cria a sessÃ£o de jogo (`init_game`).
- Define quem sÃ£o os jogadores e o estado inicial.
- Resolve o resultado final (`settle_match`).

### Modo "Delegado" (Ephemeral Validator):
- Durante a partida, a conta de estado (GameState) Ã© delegada para um validador de alta performance (MagicBlock).
- Os inputs de movimento (`move_player`) sÃ£o processados instantaneamente sem tempos de confirmaÃ§Ã£o de bloco (400ms -> ~20ms).
- TransaÃ§Ãµes de jogo sÃ£o "Gas-less" ou de custo negligenciÃ¡vel.

## ðŸ¤¼ FÃ­sica do Sumo (On-Chain)

O Unity renderiza os grÃ¡ficos bonitos, mas a verdade absoluta da posiÃ§Ã£o dos jogadores reside neste programa Rust.

### 1. MatemÃ¡tica de Ponto Fixo (Fixed Point)
A Solana e a BPF (Berkeley Packet Filter) nÃ£o lidam bem com nÃºmeros flutuantes (float). Para precisÃ£o no Unity, usamos Inteiros Escalados.

**Escala:** 100

**Exemplo:**
- Unity (Visual): 2.55 metros.
- Blockchain (LÃ³gico): 255 unidades.

### 2. Inputs de Hardware (PSG1)
A funÃ§Ã£o `move_player` aceita inputs diretos do Joystick do Play Solana Gen 1.

- Input X/Y: `i8` (Inteiro de 8 bits, varia de -127 a 127).
- Velocidade: Constante definida no contrato (ex: 10 unidades/tick).

### 3. A Regra do "Ring Out" (VitÃ³ria)
A cada movimento, o contrato verifica a distÃ¢ncia do jogador atÃ© o centro (0,0). Se a distÃ¢ncia for maior que o raio do "Dohyo" (Ringue), o estado muda imediatamente.

```rust
// LÃ³gica Simplificada (Pythagoras sem raiz quadrada para performance)
let dist_sq = (x * x) + (y * y);
let radius_sq = map_radius * map_radius;

if dist_sq > radius_sq {
    game_status = Finished;
    winner = Oponente;
}
```

## ðŸ”’ ValidaÃ§Ã£o e SeguranÃ§a

O Engine implementa proteÃ§Ãµes contra trapaÃ§as comuns em jogos P2P:

- **Autoridade de Servidor**: O cliente envia "intenÃ§Ã£o de movimento" (Input), o servidor calcula a "nova posiÃ§Ã£o". Teletransporte Ã© impossÃ­vel.
- **VerificaÃ§Ã£o de Estado**: NÃ£o Ã© possÃ­vel mover se o jogo estiver `Waiting` ou `Finished`.
- **Identidade**: Apenas as chaves pÃºblicas registradas no `init_game` (ou Session Keys delegadas) podem assinar movimentos.

## âœ… Guia de ValidaÃ§Ã£o (Testes)

Para garantir que o motor estÃ¡ pronto para o Unity, executamos o script `tests/engine.ts`.

| Teste | O que valida? | Expectativa |
|-------|---------------|-------------|
| Initialize | Setup do Tabuleiro | P1 em [-200, 0], P2 em [200, 0], Status Waiting. |
| Physics Move | Input do Joystick | Enviar x=10. PosiÃ§Ã£o deve atualizar para -190 (MatemÃ¡tica correta). |
| Ring Out | CondiÃ§Ã£o de VitÃ³ria | Mover P1 para fora do raio 500. Status deve mudar para Finished. |

### Como rodar a validaÃ§Ã£o

```bash
cd blockchain
# Garante que o build estÃ¡ atualizado
anchor build

# Roda a simulaÃ§Ã£o fÃ­sica local
anchor test --run tests/engine.ts
```

## ðŸ“ Notas de IntegraÃ§Ã£o (Unity Client)

- **DesserializaÃ§Ã£o**: Ao ler a conta GameState no C#, lembre-se de dividir as coordenadas por 100.0f para obter a posiÃ§Ã£o no mundo Unity.
- **PrediÃ§Ã£o**: O cliente deve mover o jogador visualmente antes da resposta da blockchain para suavidade, mas deve corrigir (snap) se a resposta da blockchain diferir (ReconciliaÃ§Ã£o).

## ðŸš€ Deploy to Devnet

Now that the code is fixed, push it to the network.

**Terminal:** `cd blockchain`  
**Build:** `anchor build`  
**Deploy:** `anchor deploy --provider.cluster devnet`

(Copy the Program Id output. Ensure it matches your code. If it changed, update lib.rs and MagicBlockClient.cs).

## ðŸŽ® The Validation Ritual (How to Test)

Now we connect the pieces.

### Generate the Game Address

Run your initialization script (ensure blockchain/scripts/init-game.ts uses the new struct structure, or just use the test command):

```bash
anchor test --skip-deploy --run tests/engine.ts
```

Look at the logs for "Game State Address" or "GameState Public Key".

### Configure Unity

Go to Inspector -> [NetworkManager].  
Paste that address into Game State Address.

### Fuel the Session

Since we don't have the "Transfer SOL" button yet, manually send 0.01 SOL to the Session Key Address you see in the Console log (from your Phantom wallet or CLI `solana transfer <KEY> 0.01`).

### Play

Press Play.  
Move the Joystick.

### Validation

If the ball moves in the Unity Scene View, IT WORKS.  

**Flow:** Input -> Bridge -> MagicBlock Client -> Solana Devnet -> Rust Logic -> Solana State -> MagicBlock Client -> NetworkSumo -> Transform.position.
