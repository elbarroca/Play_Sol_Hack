# üéÆ Hard-Stakes: Game Engine Module (MagicBlock)

Enquanto o M√≥dulo Banc√°rio (Bank) protege o dinheiro com cofres e regras r√≠gidas, o Engine Module √© o c√©rebro √°gil do jogo. Ele foi desenhado para rodar sobre a infraestrutura de Ephemeral Rollups da MagicBlock, permitindo uma jogabilidade fluida (sub-50ms) que seria imposs√≠vel na Mainnet da Solana padr√£o.

## üèéÔ∏è Arquitetura: Ephemeral Rollups

Este n√£o √© um Smart Contract comum. Ele opera em dois modos:

### Modo "Base" (Solana L1):
- Cria a sess√£o de jogo (`init_game`).
- Define quem s√£o os jogadores e o estado inicial.
- Resolve o resultado final (`settle_match`).

### Modo "Delegado" (Ephemeral Validator):
- Durante a partida, a conta de estado (GameState) √© delegada para um validador de alta performance (MagicBlock).
- Os inputs de movimento (`move_player`) s√£o processados instantaneamente sem tempos de confirma√ß√£o de bloco (400ms -> ~20ms).
- Transa√ß√µes de jogo s√£o "Gas-less" ou de custo negligenci√°vel.

## ü§º F√≠sica do Sumo (On-Chain)

O Unity renderiza os gr√°ficos bonitos, mas a verdade absoluta da posi√ß√£o dos jogadores reside neste programa Rust.

### 1. Matem√°tica de Ponto Fixo (Fixed Point)
A Solana e a BPF (Berkeley Packet Filter) n√£o lidam bem com n√∫meros flutuantes (float). Para precis√£o no Unity, usamos Inteiros Escalados.

**Escala:** 100

**Exemplo:**
- Unity (Visual): 2.55 metros.
- Blockchain (L√≥gico): 255 unidades.

### 2. Inputs de Hardware (PSG1)
A fun√ß√£o `move_player` aceita inputs diretos do Joystick do Play Solana Gen 1.

- Input X/Y: `i8` (Inteiro de 8 bits, varia de -127 a 127).
- Velocidade: Constante definida no contrato (ex: 10 unidades/tick).

### 3. A Regra do "Ring Out" (Vit√≥ria)
A cada movimento, o contrato verifica a dist√¢ncia do jogador at√© o centro (0,0). Se a dist√¢ncia for maior que o raio do "Dohyo" (Ringue), o estado muda imediatamente.

```rust
// L√≥gica Simplificada (Pythagoras sem raiz quadrada para performance)
let dist_sq = (x * x) + (y * y);
let radius_sq = map_radius * map_radius;

if dist_sq > radius_sq {
    game_status = Finished;
    winner = Oponente;
}
```

## üîí Valida√ß√£o e Seguran√ßa

O Engine implementa prote√ß√µes contra trapa√ßas comuns em jogos P2P:

- **Autoridade de Servidor**: O cliente envia "inten√ß√£o de movimento" (Input), o servidor calcula a "nova posi√ß√£o". Teletransporte √© imposs√≠vel.
- **Verifica√ß√£o de Estado**: N√£o √© poss√≠vel mover se o jogo estiver `Waiting` ou `Finished`.
- **Identidade**: Apenas as chaves p√∫blicas registradas no `init_game` (ou Session Keys delegadas) podem assinar movimentos.

## ‚úÖ Guia de Valida√ß√£o (Testes)

Para garantir que o motor est√° pronto para o Unity, executamos o script `tests/engine.ts`.

| Teste | O que valida? | Expectativa |
|-------|---------------|-------------|
| Initialize | Setup do Tabuleiro | P1 em [-200, 0], P2 em [200, 0], Status Waiting. |
| Physics Move | Input do Joystick | Enviar x=10. Posi√ß√£o deve atualizar para -190 (Matem√°tica correta). |
| Ring Out | Condi√ß√£o de Vit√≥ria | Mover P1 para fora do raio 500. Status deve mudar para Finished. |

### Como rodar a valida√ß√£o

```bash
cd blockchain
# Garante que o build est√° atualizado
anchor build

# Roda a simula√ß√£o f√≠sica local
anchor test --run tests/engine.ts
```

## üìù Notas de Integra√ß√£o (Unity Client)

- **Desserializa√ß√£o**: Ao ler a conta GameState no C#, lembre-se de dividir as coordenadas por 100.0f para obter a posi√ß√£o no mundo Unity.
- **Predi√ß√£o**: O cliente deve mover o jogador visualmente antes da resposta da blockchain para suavidade, mas deve corrigir (snap) se a resposta da blockchain diferir (Reconcilia√ß√£o).